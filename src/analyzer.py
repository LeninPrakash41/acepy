import ast
from typing import Dict


class Dependency:
    def __init__(self, args, returns, function):
        self.dependencies = args
        self.returns = returns
        self.function = function


def parse(code: str) -> ast.Module:
    """
    Parse source code string into an abstract syntax tree

    :param code: the source code
    :return: a single Module node of the abstract syntax tree
    """
    return ast.parse(code, mode='exec')


def analyze(tree: ast.Module) -> Dict[str, Dependency]:
    """
    Analyze AST Module to produce a map of all functions to their parameters (dependencies) and return value (result)

    :param tree: an AST Module node
    :return: a dictionary with function names as key
    """
    functions = [node for node in tree.body if isinstance(node, ast.FunctionDef)]
    dependency_map = {}

    for function in functions:
        if function.name in dependency_map:
            raise FunctionOverloadError(function.name)

        args = []
        for arg in function.args.args:
            if arg.annotation is not None:
                if isinstance(arg.annotation, ast.Str):
                    annotation = arg.annotation.s
                else:
                    annotation = arg.annotation.id
                args.append((arg.arg, annotation))

        returns = None
        if function.returns is not None:
            if isinstance(function.returns, ast.Str):
                returns = function.returns.s
            else:
                returns = function.returns.id
        dependency_map[function.name] = Dependency(args, returns, function)

    return dependency_map


def returns_are_unique(dep_map: Dict[str, Dependency]) -> bool:
    """
    Check if all return annotations in the dependency map are unique.
    Functions with no annotation (None) are ignored
    :param dep_map: a dependency map generated by analyze(tree)
    :return: true if all return annotations are unique, false otherwise
    """
    returns = [d.returns for d in dep_map.values() if d.returns is not None]
    return len(returns) == len(set(returns))


class FunctionOverloadError(Exception):
    def __init__(self, function_name: str):
        self.message = "Overloading of function: " + str(function_name) + " is not supported"

    def __str__(self):
        return self.message
